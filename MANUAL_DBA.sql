/* INICIANDO MODELAGEM FÍSICA */
CREATE DATABASE PROJETO;



/* CONECTANDO-SE AO BANCO */
USE PROJETO;



/* CIRANDO A TABELA CLIENTES */
CREATE TABLE CLIENTE (
    NOME VARCHAR (30),
	SEXO CHAR (1),
	EMAIL VARCHAR (30),
	CPF INT (11),
	TELEFONE VARCHAR (30),
	ENDERECO VARCHAR (100)	
);



/* VERIFICANDO AS TABELAS DO BANCO */
SHOW TABLES;



/* DESCOBRINDO A ESTRUTURA DAS TABELAS */
DESC CLIENTE;



/* INSERINDO DADOS NAS TABELAS */
-- FORMA 1: OMITINDO AS COLUNAS, OS VALOES DOS CAMPOS, DEVEM VIR RESPECTIVAENTE NA ORDEM DAS COLUNAS NA TABELA  
INSERT INTO CLIENTE VALUES ('JONH','M','JONH@GMAIL.COM',988638273,'22923110','MAIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ');
INSERT INTO CLIENTE VALUES ('MARY','F','MARY@HOTMAIL.COM',456893,'25078869','RIACHUELO - CENTRO - RIO DE JANEIRO - RJ');
INSERT INTO CLIENTE VALUES ('HUDO','M','HUD@BOL.COM',387620208,NULL,'FREI CANECA - CENTRO - ITARARÉ - SP');

--FORMA 2: COLOCANDO AS COLUNAS 
INSERT INTO CLIENTE (NOME,SEXO,EMAIL,CPF,TELEFONE,ENDERECO) VALUES('JILL','F','VALENTINE@STARS.EU',156887423,'12589473','BAKKER STREET - RACCON CITY - WV');



/* CARACTER CORINGA */
SELECT NOME, SEXO 
FROM CLIENTE 
WHERE ENDERECO LIKE '%RJ';



/* OPERADORES LÓGICOS */
OR  -> PARA QUE A SAÍDA DA QUERY SEJA VERDADEIRA, BASTA APENAS UMA CONDIÇÃO SEJA VERDADEIRA
AND -> PARA QUE A SAÍDA DA QUERY SEJA VERDADEIRA, TODAS AS CONDIÇÃO DEVEM SER VERDADEIRAS



/* COUNT COM ALIAS* - CONTA O NÚMERO DE LINHAS */
SELECT COUNT(*) AS "QUANTIDADE DE REGISTROS" FROM CLIENTES;



/* GROUP BY - DISTRIBUI A CONTAGEM */
SELECT SEXO, COUNT((*) FROM CLIENTE GROUP BY SEXO;



/* MAX, MIN, AVG */ 
SELECT MAX (FEVEREIRO) AS MAIOR_FEV
FROM VENDEDORES;

SELECT MIN (FEVEREIRO) AS MENOR_FEV
FROM VENDEDORES;

SELECT AVG (FEVEREIRO) AS MEDIA_FEV
FROM VENDEDORES;

SELECT MAX(JANEIRO) AS MAX_JAN,
       MIN(JANEIRO) AS MIN_JAN,
	   AVG(JANEIRO) AS MED_JAN
FROM VENDEDORES;



/* SUM */
SELECT SUM(JANEIRO) AS TOTAL_JAN,
SELECT SUM(FEVEREIRO) AS TOTAL_FEV,
SELECT SUM(MARCO) AS TOTAL_MAR
FROM VENDEDORES;

SELECT SUM(MARCO) AS TOTAL_MAR
FROM VENDEDORES
GROUP BY SEXO;



/* OPERAÇÃO EM LINHA */
SELECT NOME, 
       JANEIRO, 
	   FEVEREIRO.
	   (JANEIRO + FEVEREIRO) AS TOTAL,             ---> OPERAÇÃO NA LINHA.
	   (JANEIRO + FEVEREIRO) * .25 AS DESCONTO     ---> OPERAÇÃO NA LINHA.
FROM VENDEDORES;



/* TRUNCATE */
SELECT TRUNCATE(MAX(JANEIRO),2) AS MAX_JAN   --------> TRUNCATE(100.9926,2) => 100.99 O NUMERO '2' COMO SEGDUNDO ARGUMENTO DA FUNÇÃO É A QUANTIDADE DE CASAS QUE IRÃO RETORNAR.
FROM VENDEDORES;



/* EXEMPLO DE QUERY COM CONDIÇÃO DUPLA */
SELECT idFuncionario, nome, email 
FROM funcionarios 
WHERE (departamento='Filmes' AND sexo='Feminino') OR (departamento='Lar'AND sexo='Feminino');



/* FILTRAGEM DE NULOS - IS NULL OU IS NOT NULL */
SELECT NOME, SEXO, ENDERECO
FROM CLIENTE
WHERE EMAIL IS NULO;



/* UPDATE: ATUALIZAÇÃO DE UM EMAIL DE UMA CLIENTE */
UPDATE CLIENTE 
SET EMAIL = 'LILIAN@HOTMAIL.COM'
WHERE NOME = 'LILIAN';



/* DELETE */
DELETE FROM CLIENTE
WHERE NOME = 'ANA';

DELETE 
FROM CLIENTE
WHERE NOME = 'CARLA' AND EMAIL = 'CARLA@GMAIL.COM';



/* PROJEÇÃO (SELECT) --> TUDO QUE VOCÊ QUE VER NA TELA! */
SELECT 2 + 2 AS SOMA, NOME, NOW() FROM CLIENTES;
SOMA: COLUNA QUE ESTÁ SENDO PROJETADA,
NOME: COLUNA JÁ EXISTENTE DE UMA TABELA.
NOW(): COLUNA DE FUNÇÃO (HORA).



/* SELEÇÃO (WHERE) --> É UM SUCONJUNTO DO CONJUNTO TOTAL DE REGISTROS DE UMA TABELA */
SELECT NOME, SEXO, EMAIL     *PROJEÇÃO*
FROM CLIENTE                 *ORIGEM*
WHERE SEXO = 'F';            *SELEÇÃO*



/* JUNÇÃO --> INNER JOIN */
SELECT NOME, SEXO, BAIRRO, CIDADE
FROM CLIENTE
INNER JOIN ENDEREÇO
ON ID_CLIENTE = ID_CLIENTE; 

SELECT NOME, SEXO, BAIRRO, CIDADE   *PROJEÇÃO
FROM CLIENTE                        *ORIGEM
INNER JOIN ENDEREÇO                 *JUNÇÃO
ON ID_CLIENTE = ID_CLIENTE          
WHERE SEXO = 'F';                   *SELEÇÃO

SELECT C.NOME, C.SEXO, E.BAIRRO, E.CIDADE, T.TIPO, T.NUMERO         --> INICIO DE COLUNA, VEM O NOME DADO A TABELA: C - CLIENTE, E - ENDERECO, T - TELEFONE
FROM CLIENTE C                                                      --> ORIGEM
INNER JOIN ENDERECO E                                               --> INNER JOIN ENTRE CLIENTE E ENDERECO
ON C.INDCLIENTE = E.IDCLIENTE                                       --> CHAVE 1
INNER JOIN TELEFONE T                                               --> INNER JOIN ENTRE CLIENTE E ENDERECO
ON C.CLIENTE = T.IDCLIENTE;                                         --> CHAVE 2



/* CATEGORIA DE LINGUAGENS */
--> DML - DATA MANIPULATION LANGUAGE: INSERT, UPDATE, DELETE..
INSERT INTO CLIENTE VALUES (NULL, 'PAULA','M',NULL, '54681');        --> SEXO ESTÁ ERRADO!

SELECT * FROM CLIENTE;                                               --> AVERIGUAR SE REALMENTE ESTÁ ERRADO E DESCOBRE O IDCLIENTE, QUE É 7!

UPDATE CLIENTE
SET SEXO = 'F'
WHERE IDCLIENTE = 7;                                                 --> CORRIGE O SEXO PARA 'F'!

--> DDL - DATA DEFINITION LANGUAGE: CREATE, DROP, ALTER..
CREATE TABLE PRODUTO (
IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT
NOME_PRODUTO VARCHAR(30) NOT NULL,
PRECO INT,
FRETE FLOAT(10,2) NOT NULL
);

-- USO DO ALTER TABLE!

-- CHANGE E MODIFY:
ALTER TABLE PRODUTO
CHANCE PRECO VALOR_UNITARIO INT NOT NULL,          --> ALTERANDO NOME DE UMA COLUNA - CHANGE --> PRECO PARA VALOR_UNITARIO

ALTER TABLE PRODUTO
CHANCE VALOR_UNITARIO VALOR_UNITARIO INT,          --> ALTERANDO A COLUNA VALOR_UNITARIO, PARA ACEITAR NULL
 
ALTER TABLE PRODUTO
MODIFY VALOR_UNITARIO VARCHAR(50) NOT NULL,        --> ALTERANDO O TIPO DE UMA COLUNA - MODIFY 

-- ADICIONANDO COLUNAS - ADD:
ALTER TABLE PRODUTO
ADD PESO FLOAT(10,2) NOT NULL; 
 
-- APAGANDO COLUNA - DROP:
 ALTER TABLE PRODUTO
 DROP COLUMN PESO;
 
-- ADICIONANDO COLUNA EM UMA ORDEM ESPECIFICA:
ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL
AFTER NOME_PRODUTO;

ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL
FIRST;  --> PRIMEIRA DE TODAS



/* IN */
SELECT * FROM CLIENTE
WHERE IDCLIENTE IN (12,13,18,19);              --> COM O "IN", NÃO PRECISA REPETIR O COMANDO PARA CADA IDCLIENTE



/* 1° EXEMPLO DE CONSULTA: */
SELECT C.NOME, C.EMAIL, T.EMAIL AS CELULAR     --> PROJEÇÃO
FROM CLIENTE C                                 --> ORIGEM
INNER JOIN ENDERECO E                          --> JUNÇÃO
ON C.IDCLIENTE = E.ID_CLIENTE                  --> CHAVE - DA TABELA C COM E, ATRAVÉS DE ID_CLIENTE
INNER JOIN TELEFONE                            --> JUNÇÃO
ON C.IDCLIENTE = T.ID_CLIENTE                  --> CHAVE - DA TABELA C COM T, ATRAVÉS DE ID_CLIENTE
WHERE TIPO = 'CEL'                             --> SELEÇÃO OU FILTROS
AND ESTADO = 'RJ';                             --> SELEÇÃO OU FILTROS
 


/* IFNULL() */
SELECT C.NOME 
       IFNULL(C.EMAIL,'NÃO TEM EMAIL') AS EMAIL    --> SE FOR NULO, COLOCAR 'NÃO TEM EMAIL'
	   E.ESTADO
	   T.NUMERO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
INNER JOIN TELEFONE E
ON C.IDCLIENTE = E.ID_CLIENTE;



/* VIEW */
CREATE VIEW v_RELATORIO AS
SELECT C.NOME 
       C.SEXO 
	   C.EMAIL 
	   T.TIPO 
	   T.NUMERO 
	   E.BAIRRO 
	   E.CIDADE 
	   E.ESTADO 
FROM CLIENTE C
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E 
ON C.IDCLIENTE = E.ID_CLIENTE;

-- AGORA PARA CHAMAR A VIEW, QUE É UM "SAVE" DE UMA QUERRY, QUANDO CHAMAR A VIEW, É A MESMA COISA DE FAZER A QUERRY.
SELECT * FROM v_RELATORIO;

SELECT NOME, NUMERO, EMAIL 
FROM v_RELATORIO;

-- PARA VER AS VIEWS JÁ CRIADAS:
SHOW TABLES;

--APAGAR VIEW:
DROP VIEW RELATORIO;



/* SUBQUERYE */
SELECT NOME, MARÇO
FROM VENDEDORES
WHERE MARÇO = (SELECT MIN(MARÇO) FROM VENDEDORES);

SELECT COUNT(DISTINCT id_cliente)                        --> DECISIONS CARDS, CONTAS ATIVADAS
FROM t_cliente
WHERE id_cliente 
IN (SELECT id_cliente FROM t_venda WHERE fl_status_venda = 'A');



/* ORDER BY */    -->PODER ORDENAR PELO NOME DA COLUNA OU PELO NUMERO DA COLUNA
SELECT * 
FROM ALUNOS
ORDER BY MATRICULA, NOME;

SELECT * 
FROM ALUNOS
ORDER BY 1, 2;

SELECT * 
FROM ALUNOS
ORDER BY MATRICULA, NOME DESC;

--DESC OU ASC
ASC - ASCENDENTE
DESC - DESCENDENTE



/* DELIMITER */
O DELIMITER PADRÃO É O ';', O COMANDO SÓ SERÁ EXECUTADO A PARTIR DO ';'

--PARA MUDAR O DELIMITER
"DEMIMITER &" --> SELECT * FROM ALUNOS $



/* PROCEDURE */
--> STORED PROCEDURE 
DEMILITER $  --> MUDAR O DELIMITADOR PARA CRIAR A PROCEDURE!

CREATE PROCEDURE NOME()
BEGIN 
     QUALQUER PROGRAMAÇÃO
END 
&

-----------------------------------------EXEMPLO:
CREATE PROCEDURE NOME_EMPRESA()
BEGIN 
     SELECT 'UNIVERSIDADE DOS DADOS' AS EMPRESA
END
$

-- >PROCEDURE COM PARAMETROS
CREATE PROCEDURE CONTA()
BEGIN
     SELECT 10 + 10 AS CONTA;
END
$

DEMILITER $  --> MUDAR O DELIMITADOR PARA CRIAR A PROCEDURE!
CREATE PROCEDURE CONTA(NUMERO1 INT, NUMERO2 INT)
BEGIN
     SELECT NUMERO1 + NUMERO2 AS CONTA;
END
$

CALL CONTA(50,100)$           -->CHAMANDO A PROCEDURE E COLOCANDO OS VALORES DE NUMERO1 E NUMERO2!

--> CHAMANDO PROCEDURE 
CALL NOME_EMPRESA $

--> DELETANDO PROCEDURE
cursores  PROCEDURE CONTA;

----------------------------------------------------> EXEMPLO 1:
CREATE TABLE cursos(
idcurso INT PRIMARY KEY AUTO_INCREMENT,
nome VARCHAR(30) NOT NULL,
horas INT(3) NOT NULL,
valor FLOAT(10,2) NOT NULL
);

INSERT INTO cursos VALUES (NULL, 'JAVA', 30, 500.00);
INSERT INTO cursos VALUES (NULL, 'DBA', 60, 800.00);

DELIMITER # -------------------> MUDAR DELIMITER PARA A CRIAÇÃO DA PROCEDURE PARA A CRIAÇÃO DE NOVOS CURSOS

CREATE PROCEDURE cad_curso(p_nome VARCHAR(30),p_horas INT(3),p_valor FLOAT(10,2))    ------>FORMATO DA PROCEDURE, O PRIMEIRO CAMPO É UM 'AUTO_INCREMENT', NÃO PRECISA PREENCHER.
BEGIN
    INSERT INTO cursos VALUES (NULL,p_nome,p_horas,p_valor);                         ------>NULL DO PRIMEIRO CAMPO, POIS É UM AUTO_INCREMENT, O NOME DADO NO FORMATO DA PROCEDURE.
END
#

DELIMITER ;    --------------> TROCAR DELIMITADOR PARA O ;
 
CALL cad_curso ('SQL',50,300.00);              -------------> CHAMAR A PROCEDURE E COLOCAR OS VALORES DESEJADOS, POIS A PROCEDURE, FARÁ O CADASTRO DOS NOVOS CURSOS.
CALL cad_curso ('ORACLE',180,900.00);
CALL cad_curso ('POWER BI',100,700.00);

----------------------------------------------------> EXEMPLO 2:

DELIMITER #  -------------------> MUDAR DELIMITER PARA A CRIAÇÃO DA PROCEDURE PARA CONSULTAR UM CURSO, PELO SEU idcurso.

CREATE PROCEDURE le_curso(p_idcurso INT)   
BEGIN
    SELECT nome, horas, valor FROM cursos
    WHERE idcurso = p_idcurso;
END
#

DELIMITER ;   



/* ALTERANDO ESTRUTURA DE TABELAS */
--> ADICIONANDO UMA PRIMARY KEY PK 
ALTER TABLE tabela
ADD PRIMARY KEY (COLUNA1); 

--> ADICIONANDO UMA COLUNA SME PROSIÇÃO
ALTER TABLE tabela
ADD COLUNA VARCHAR(30);

--> ADICIONANDO COLUNA COM POSIÇÃO
ALTER TABLE tabela
ADD COLUMN COLUNA4 VARCHAR(30) NOT NULL UNIQUE
AFTER COLUNA3;

--> MUDAR O NOME DA TABELA]
ALTER TABLE tabela
RENAME pessoa;

--> ADICIONANDO UMA FOREIGN KEY FG
ALTER TABLE TIME
ADD FOREIGN KEY (id_pessa)
REFERENCES pessoa (coluna1); 

--> DETALHAR TABELA
SHOW CREATE TABLE time;     --> VAI DETALHAR A TABELA



/* CONSTRAINTS */                
CREATE TABLE CLIENTE(
	IDCLIENTE INT,
	NOME VARCHAR(30) NOT NULL
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_CLIENTE INT
);

--> ADICIONANDO CONSTRAINTS                               --> CONSTRAINT SÃO AS REGRAS DE LIGAÇÃO, ENTRE CHAVES
ALTER TABLE CLIENTE ADD CONSTRAINT PK_CLIENTE
PRIMARY KEY(IDCLIENTE);                                   --> PRIMARY KEY É IDCLIENTE 

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE   --> CHAVE ESTRABGEIRA, IDCLIENTE DA TABELA CLIENTE E TELEFONE.
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

SHOW CREATE TABLE TELEFONE;

--> DICIONARIO DE DADOS, GUARDA O META DADO.
SHOW DATABASES;                                           --> VER QUAIS SÃO AS BASES DO SISTEMA

USE INFORMATION_SCHEMA;                                   --> BASE DO SISTEMA, PERTENCEM AO DICIONARIO DE DADOS

STATUS

SHOW TABLES;                                              --> PROCURAR A TABLE COM AS CONSTRAINT                

DESC TABLE_CONSTRAINTS;

SELECT CONSTRAINT_SCHEMA AS "BANCO",
	   TABLE_NAME AS "TABELA",
	   CONSTRAINT_NAME AS "NOME REGRA",
	   CONSTRAINT_TYPE AS "TIPO"
	   FROM TABLE_CONSTRAINTS
	   WHERE CONSTRAINT_SCHEMA = 'COMERCIO';

--> APAGANDO CONSTRAINTS 
USE COMERCIO;

ALTER TABLE TELEFONE
DROP FOREIGN KEY FK_CLIENTE_TELEFONE;

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

--> AÇÕES DE CONSTRAINTS 
SHOW TABLES;

INSERT INTO CLIENTE VALUES(1,'RICARDO');
INSERT INTO CLIENTE VALUES(2,'CLARA');
INSERT INTO CLIENTE VALUES(3,'JULIO');
INSERT INTO CLIENTE VALUES(4,'ANA');

INSERT INTO TELEFONE VALUES(10,'CEL','37834334',2);
INSERT INTO TELEFONE VALUES(20,'RES','67465656',2);
INSERT INTO TELEFONE VALUES(30,'CEL','88665645',1);
INSERT INTO TELEFONE VALUES(40,'RES','77543546',3);
INSERT INTO TELEFONE VALUES(50,'COM','75454675',1);
INSERT INTO TELEFONE VALUES(60,'CEL','76765455',4);

SELECT NOME, TIPO, NUMERO
FROM CLIENTE
INNER JOIN TELEFONE
ON IDCLIENTE = ID_CLIENTE;

--> ERRO DE REFERENCIA
DELETE FROM CLIENTE WHERE IDCLIENTE = 1;

--> CORRIGIR ERRO
DELETE FROM TELEFONE
WHERE ID_CLIENTE = 1;
DELETE FROM CLIENTE WHERE IDCLIENTE = 1;

--> APAGANDO A FOREIGN KEY 
ALTER TABLE TELEFONE DROP FOREIGN KEY FK_CLIENTE_TELEFONE;

--> RECRIANDO A FK 
ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE)
ON DELETE CASCADE;

SELECT NOME, TIPO, NUMERO
FROM CLIENTE
INNER JOIN TELEFONE
ON IDCLIENTE = ID_CLIENTE;

DELETE FROM CLIENTE WHERE IDCLIENTE = 2;

ALTER TABLE TELEFONE DROP FOREIGN KEY FK_CLIENTE_TELEFONE;

ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE)
ON DELETE SET NULL;

SELECT NOME, TIPO, NUMERO
FROM CLIENTE
INNER JOIN TELEFONE
ON IDCLIENTE = ID_CLIENTE;

SELECT * FROM CLIENTE;

DELETE FROM CLIENTE WHERE IDCLIENTE = 3;

SELECT * FROM TELEFONE;



/* TRIGGERS */

--> MUDAR DELIMITADOR PARA #

CREATE TRIGGER NOME
BEFORE/AFTER INSERT/DELETE/UPDATE  ON TABELA
FOR EACH ROW (PARA CADA LINHA)
BEGIN --> INICIO
    QUALQUER COMANDOI SQL;
END  --> FIM 
#

--> VOLTAR DELIMITADOR PARA ;

--------------------------------------EXEMPLO-------------------CRIANDO UMA TABELA BACKUP!
-->CRIANDO DUAS TABLES, A usuario E A bkp_usuario

create table usuario(
idusuario int primary key AUTO_INCREMENT,
nome varchar(30),
login varchar(30),
senha varchar(100)
);

create table bkp_usuario(
idbackup int primary key AUTO_INCREMENT,
idusuario int,
nome varchar(30),
login varchar(100)
);

-->> CRIANDO TRIGGERS, PARA QUANDO UM USUARIO FOR DELETADO, ELE SER SALVO AUTOMATICAMENTE EM UMA TABLE BACKUP

DELIMITER $

CREATE TRIGGER BACKUP_USER
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN
      INSERT INTO bkp_usuario VALUES
	  (NULL, OLD.idusuario, OLD.nome, OLD.login);
END
$

DELIMITER ;

-->INSERIR UM USUARIO NA TABELA USUARIO
INSERT INTO USUARIO VALUES(NULL,'ANDRADE','ANDRADE2009','HEXACAMPEAO');

SELECT * FROM USUARIO;
--VERIFICA O ID DO USUARIO, NO CASO ID=1

DELETE FROM USUARIO WHERE IDUSUARIO = 1;
--DELETA O USUARIO

--CHAMA A TABELA BACKUP, QUE TEVE O USUARIO ADICIONADO PELA TRIGGER, QUANDO O USUARIO FOI DELETADO.
SELECT * FROM bkp_usuario;

--O USUARIO DELETADO DA TABEÇA USARIO, DEVE SER CRIADO NA TABELA bkp_usuario.

--------------------------------------EXEMPLO-------------------CRIANDO UM BACKUO EM OUTRO BANCO!
-->DATABASE LOJA

CREATE DATA BASE LOJA;

USE LOJA;

CREATE TABLE PRODUTO(
   IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
   NOME VARCHAR(30),
   VALOR FLOAT(10,2)
);

--> CRIANDO O BANCO DE BACKUP

CREATE DATABASE BACKUP_PRODUTO;

USE BACKUP;

CREATE TABLE BKP_PRODUTO(
   IDBKP INT PRIMARY KEY AUTO_INCREMENT,
   IDPRODUTO INT,
   NOME VARCHAR(30),
   VALOR FLOAT(10,2)
);

--> INSERT EM UMA TABLE DE UM BANCO, NÃO ESTANDO CONECTADO NELE:
insert into BACKUP_PRODUTO.BKP_PRODUTO values (null, 1000, 'teste', 0.0);
-- BACKUP_PRODUTO.BKP_PRODUTO -- DATABASE.TABLE

--> CRIANDO A TRIGGER:

DELIMITER $

CREATE TRIGGER BACKUP_PROD
BEFORE INSERT ON PRODUTO
FOR EACH ROW 
BEGIN
      INSERT INTO BACKUP_PRODUTO.BKP_PRODUTO VALUES (NULL,NEW.IDPRODUTO,NEW.NOME, NEW.VALOR);
END	  
$

INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE DADOS',150.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE ENG',190.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE PT',120.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE SQL',190.00);
--> ESSES INSERT SERÃO GRAVADOS NOS DOIS BANCOS!

--------------------------------------EXEMPLO------------------TRIGGER PARA AUDITORIA, MOSTRAR QUANDO O PRODUTO FOI ALTERADO, DELETADO OU INSERIDO E GRAVAR NA TABELA BKP_PRODUTO.
-->CRIANDO DATA BASES ou DELETANDO BASES
CREATE DATABASE backup;
 
-->CRIANDO AS TABLES 
CREATE TABLE PRODUTO(
   IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
   NOME VARCHAR(30),
   VALOR FLOAT(10,2)
);

CREATE TABLE BKP_PRODUTO(
   IDBKP INT PRIMARY KEY AUTO_INCREMENT,
   IDPRODUTO INT,
   NOME VARCHAR(30),
   VALOR_ORIGINAL FLOAT(10,2),
   VALOR_ALTERADO FLOAT(10,2),
   DATA DATETIME,
   USUARIO VARCHAR(30),
   EVENTO CHAR(1)
);

--> INSERINDO DADOS NA TABLE LOJA.PRODUTO: 
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE DADOS',150.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE ENG',190.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE PT',120.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE SQL',190.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE R',125.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE CSS',182.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE HTML',151.00);
INSERT INTO PRODUTO VALUES(NULL, 'LIVRO DE PLSQL',140.00);

--> CONSULTAS: 
SHOW DATABASES;

USE loja;
USE backup;

SHOW TABLES;

SELECT * FROM loja.produto;
SELECT * FROM backup.bkp_produto;

SHOW STATUS;

SHOW TRIGGERS;
DROP TRIGGER BACKUP_PROD;

--> CRIANDO TRIGGER PARA REGISTRAR NA BACKUP.BKP_PRODUTO OS UPDATES:
DELIMITER $
CREATE TRIGGER AUDIT_PRODUT_UPDATE
AFTER UPDATE ON PRODUTO
FOR EACH ROW 
BEGIN
      INSERT INTO backup.bkp_produto VALUES (
      NULL, 
      OLD.IDPRODUTO, 
      OLD.NOME, 
      OLD.VALOR, 
      NEW.VALOR, 
      NOW(), 
      CURRENT_USER(), 
      'U'
);
END	  
$
DELIMITER ;

--> FAZENDO UM UPDATE EM UM VALOR, PARA QUE NA TABELA bkp_produto, SEJA REGISTRADO:
UPDATE PRODUTO SET VALOR = 75.00 WHERE IDPRODUTO = 5;

-->CONFERIR NA bkp_produto:
SELECT * FROM backup.bkp_produto;


--> CRIANDO TRIGGER PARA REGISTRAR NA BACKUP.BKP_PRODUTO OS NOVOS REGISTROS, REGISTROS DELETADOS E OS MODIFICADOS:
DELIMITER $
CREATE TRIGGER AUDIT_PRODUT_INSERT
AFTER INSERT ON LOJA.PRODUTO
FOR EACH ROW 
BEGIN
      INSERT INTO backup.bkp_produto VALUES (
      NULL, 
      NEW.IDPRODUTO, 
      NEW.NOME, 
      NEW.VALOR, 
      NEW.VALOR, 
      NOW(), 
      CURRENT_USER(), 
      'A'
);
END	  
$
DELIMITER ;


DELIMITER $
CREATE TRIGGER AUDIT_PRODUT_DELETE
BEFORE DELETE ON LOJA.PRODUTO
FOR EACH ROW 
BEGIN
      INSERT INTO backup.bkp_produto VALUES (
      NULL, 
      OLD.IDPRODUTO, 
      OLD.NOME, 
      OLD.VALOR, 
      OLD.VALOR, 
      NOW(), 
      CURRENT_USER(), 
      'D'
);
END	  
$
DELIMITER ;


DELIMITER $
CREATE TRIGGER AUDIT_PRODUT_INSERT
AFTER INSERT ON LOJA.PRODUTO
FOR EACH ROW 
BEGIN
      INSERT INTO backup.bkp_produto VALUES (
      NULL, 
      NEW.IDPRODUTO, 
      NEW.NOME, 
      NEW.VALOR, 
      NEW.VALOR, 
      NOW(), 
      CURRENT_USER(), 
      'A'
);
END	  
$
DELIMITER ;

-->INSERIR NOVO REGISTRO NA LOJA.PRODUTO:
INSERT INTO LOJA.PRODUTO VALUES(NULL, 'LIVRO DE Y', 55.00);

UPDATE PRODUTO SET VALOR = 75.00 WHERE IDPRODUTO = 5;

DELETE FROM loja.produto WHERE IDPRODUTO = 11;

-->CONFERIR NA bkp_produto:
SELECT * FROM backup.bkp_produto;


/* CURSORES */

CREATE DATABASE CURSORES;

SHOW DATABASES;

USE CURSORES;

SHOW TABLES;

CREATE TABLE VENDEDORES (
    IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30),
    JAN INT,
    FEV INT,
    MAR INT 
);

INSERT INTO VENDEDORES VALUES(NULL, 'MAFRA', 32432, 242664, 574565);
INSERT INTO VENDEDORES VALUES(NULL, 'CLARA', 65465, 65443, 653454);
INSERT INTO VENDEDORES VALUES(NULL, 'JOAO', 12432, 65356, 8756);
INSERT INTO VENDEDORES VALUES(NULL, 'LLIAN', 4567, 9676, 8765);
INSERT INTO VENDEDORES VALUES(NULL, 'LILIAN', 4567, 9676, 8765);
INSERT INTO VENDEDORES VALUES(NULL, 'ANTONIO', 3467, 68756, 99765);
INSERT INTO VENDEDORES VALUES(NULL, 'GLORIA', 54786, 76889, 7098);

SELECT * FROM CURSORES.VENDEDORES;
SELECT * FROM CURSORES.VENDEDORES_TOTAL;

SELECT 
NOME, 
(JAN+FEV+MAR) AS TOTAL 
FROM CURSORES.VENDEDORES;

SELECT 
NOME, 
(JAN+FEV+MAR) AS TOTAL,
(JAN+FEV+MAR)/3 AS MEDIA
FROM CURSORES.VENDEDORES;

CREATE TABLE VENDEDORES_TOTAL (
    IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30),
    JAN INT,
    FEV INT,
    MAR INT,
    TOTAL INT,
    MEDIA INT
);

---------------------------------

DELIMITER $
CREATE PROCEDURE INSEREDADOS()
BEGIN
    DECLARE FIM INT DEFAULT 0;
	DECLARE VAR1, VAR2, VAR3, VTOTAL, VMEDIA INT;
	DECLARE VNOME VARCHAR(50);
      
	DECLARE REG CURSOR FOR(
	    SELECT NOME, JAN, FEV, MAR FROM VENDEDORES 
	);
	  
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIM = 1;  
      
	OPEN REG;
      
	REPEAT
      
	  FETCH REG INTO VNOME, VAR1, VAR2, VAR3;
        IF NOT FIM THEN
		SET VTOTAL = VAR1 + VAR2 + VAR3;
		SET VMEDIA = VTOTAL / 3;
          
            INSERT INTO VENDEDORES_TOTAL VALUES(VNOME, VAR1, VAR2, VAR3, VTOTAL, VMEDIA);
	  END IF;
      
	UNTIL FIM END REPEAT;
    
      CLOSE REG;
END	  
$
DELIMITER ;

--------------------------------------------------

CALL INSEREDADOS();
SELECT INSERE_DADOS();

DROP PROCEDURE INSERE_DADOS;

DROP DATABASE CURSORES;


-------------------------------------------------EXEMPLO 2-----------------------------------------------------------------
SHOW DATABASES;

create database if not exists AulaCursor;

use AulaCursor;

show tables;

select * from curso;

select * from aluno;

create table curso (
    codigo varchar(5) not null,
    nome varchar(30) not null,
    constraint pk_Curso primary key (codigo)
);

create table ALuno (
    matricula varchar(7) not null,
    nome varchar(40) not null,
    idade int not null,
    cod_Curso varchar(5) null,
    constraint pk_Aluno primary key (matricula),
    constraint fk_Curso foreign key (cod_Curso) references Curso (codigo) on delete set null
    );
    
insert into Curso values ('tinf', 'Técnico em Informática');
insert into Aluno values ('0011111', 'Tony Stark','53','tinf');
insert into Aluno values ('0022222', 'Wendel Bezerra','46',null);
insert into Aluno values ('0033333', 'Maria Luiza','1','tinf');
insert into Aluno values ('0044444', 'Moisés Pereira','38',null);
insert into Aluno values ('0077777', 'Mr.Anderson','28',null);

delimiter //
create procedure BuscaSemMatricula(inout lista text)
begin
    declare nomeBuscado varchar(40);
    declare terminou int default 0; 
    declare verifica cursor for select a.nome
								from   ALuno a
                                where  a.cod_Curso is null;
    declare continue handler for not found set terminou = 1;
    
    open verifica;
    buscaNomes : loop
        fetch verifica into nomeBuscado;
        if terminou = 1 then 
            leave buscaNomes;
		end if;
        set lista = concat(nomeBuscado, ', ', lista);
    end loop buscaNomes;
end //
delimiter ;

set @relatorio = '';

call BuscaSemMatricula(@relatorio);

select @relatorio;

--RESULTADO: Mr.Anderson, Moisés Pereira, Wendel Bezerra, 





DCL - DATA CONTROL LANGUAGE 
TCL - TRANSACTION CONTROL LANGUAGE 